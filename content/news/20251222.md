---
title: "Nature vs Golang: Performance Benchmark"
date: 2025-12-22
---

Nature is a relatively new programming language that is lightweight, simple, and easy to learn. It draws inspiration from Golang in its design philosophy and runtime architecture, while offering richer syntax features that make it more suitable for business development. It is also continuously exploring broader application areas.

Performance is a key metric for evaluating a programming language's core competitiveness. Next, we will conduct performance tests on the Nature programming language from four dimensionsâ€”IO Concurrency, CPU Computation, C Language FFI, and Coroutine Performanceâ€”using Golang as the benchmark.

## Test Environment

| Configuration | Details                                                                 |
|---------------|-------------------------------------------------------------------------|
| Host Machine  | Apple Mac mini M4, 16GB RAM                                             |
| Test Environment | Linux Virtual Machine (Ubuntu 6.17.8, aarch64 architecture)             |
| Compiler / Runtime Version | Nature: v0.7.0 (release build 2025-12-15)<br>Golang: go1.23.4 linux/arm64<br>Rust: cargo 1.85.0<br>Node.js: v20.16.0 |

> All tests use identical code logic implementations. The code examples in this article are presented using the Nature programming language.

## IO Concurrency

IO concurrency is the core capability of network services. This test uses HTTP server stress testing to comprehensively evaluate the language's IO scheduling, CPU utilization, and GC stability.

**Nature Code Example**

```js
import http  
  
fn main() {  
    var app = http.server()  
  
    app.get('/', fn(http.request_t req, ptr<http.response_t> res):void! {  
        res.send('hello nature')  
    })  
  
    app.listen(8888)  
}
```

**ab Tool Test Command**

```sh
ab -n 100000 -c 1000 http://127.0.0.1:8888/
```

- -n 100000: Total requests: 100,000
- -c 1000: Concurrency level: 1000

**Test Results**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20251222101641064.png)

We can see that Nature outperforms Golang in HTTP concurrency performance, which is an impressive achievement for an early-stage programming language.

Since both Nature and Node.js use libuv as their IO backend, Node.js is also included in this benchmark (libuv is not thread-safe, so both Node.js and Nature run their event loops in a single thread). However, as a compiled language, Nature's concurrency handling capabilities far surpass Node.js.

## CPU Computation

We use the classic recursive Fibonacci sequence calculation `fib(45)` to test the language's CPU computation and high-frequency function call overhead.

 **Nature Code Example**

```js
fn fib(int n):int {
    if (n <= 1) {
        return n
    }
    
    return fib(n - 1) + fib(n - 2)
}
```

**Test Method**

```sh
time ./main
1134903170./main  2.50s user 0.01s system 101% cpu 2.473 total
```

**Test Results:**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20251222101710912.png)

Both Nature and Golang use self-developed compiler backends, and their performance is comparable. The reason for higher latency compared to Rust is primarily due to additional processing performed before function execution.

Golang uses preemptive scheduling, so it doesn't need to worry about GC safepoints, but it still needs to check if the coroutine stack needs expansion, as seen in the following assembly instructions:

```
// stack
f9400b90 	ldr	x16, [x28, #16]
eb3063ff 	cmp	sp, x16
540002a9 	b.ls	7869c <main.Fib+0x5c>  // b.plas
```

Nature uses cooperative scheduling, so it needs to handle GC safepoints. However, Nature uses shared-stack coroutines, so it doesn't need to worry about stack expansion.

```
# safepoint
adrp    x16, 0xa9d000
add     x16, x16, #0xeb0

ldr     x16, [x16]
cmp     x16, #0x0
b.ne    0x614198 <main.fib.preempt>
```

Nature's safepoint implementation still has room for optimization. If we switch to SIGSEGV-based triggering in the future, function call performance will be further improved.

Nature and Golang use completely different scheduling strategies and coroutine design schemes. What differences does this bring? Let's look at the subsequent tests ðŸ‘‡

## C Language FFI

We test the efficiency of collaboration with C by calling the sqrt function from the C standard library 100 million times.

**Nature Code Example**

```js
import libc  
  
fn main() {  
    for int i = 0; i < 100000000; i+=1 {  
        var r = libc.sqrt(4)  
    }  
}
```

**Test Results**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20251222101741607.png)

We can see that Nature has a significant advantage over Golang in C FFI. This is because Golang's CGO module has very high performance costsâ€”its independent-stack coroutine and preemptive scheduling design are difficult to integrate with C, requiring complex processing.

In contrast, Nature's shared-stack and cooperative scheduling design is more compatible with C. In fact, Nature can directly call any binary library that complies with ABI specifications, not just C.

In scenarios such as high-performance computing and low-level hardware operations, Nature can seamlessly integrate core modules written in C/Assembly, compensating for the shortcomings of GC languages in extreme performance scenarios while balancing development efficiency and low-level performance.

## Coroutines

Coroutines are core components of modern concurrent programming. This test evaluates Nature and Golang's coroutine scheduling efficiency, memory usage, and response speed through a "million coroutines creation + switching + simple computation" scenario.

**Nature Code Example**

```js
import time  
import co  
  
var count = 0  
  
fn sum_co() {  
    count += 1  
    co.sleep(10000)  // ms, Remove this line if no sleep
}  
  
fn main() {  
    var start = time.now().ms_timestamp()  
    for int i = 0; i < 1000000; i+=1 {  
        go sum_co()  
    }  
  
    println(time.now().ms_timestamp() - start)  // create time
    
    int prev_count = 0  
    for prev_count != count {  
        println(time.now().ms_timestamp() - start, count)  
        prev_count = count  
        co.sleep(10)  
    }  
    println(time.now().ms_timestamp() - 10 - start) // calc time
    co.sleep(3000) // ms
} 
```

**Test Results**

![](https://raw.githubusercontent.com/weiwenhao/pictures/main/20251222101802914.png)

| Language | Creation Time (ms) | Computation Time (ms) | Computation Time Without Sleep (ms) | Memory Usage |
|----------|---------------------|------------------------|--------------------------------------|--------------|
| Nature   | 540                 | 564                    | 170                                  | 900+M        |
| Golang   | 1000                | 1015                   | 140                                  | 2500+M       |

Nature's coroutines exhibit excellent comprehensive performance, with memory usage far lower than Golang's. This is achieved even though Nature's coroutine scheduler has not been optimized yet. We expect further optimizations to Nature's coroutine scheduler in future versions, which will deliver even more impressive results.

## Conclusion

This is an informal performance test, but even in these rough tests, the Nature programming language has demonstrated capabilities and potential beyond expectations. As an early-stage programming language, its runtime and compiler still have significant room for optimization, and performance will further improve when the official version is released.

Based on its current performance, Nature is undoubtedly a programming language worth paying attention to and trying out, especially in server-side development fields such as cloud-native, network services, and API development.