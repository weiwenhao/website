在 nature 中每一个变量都有一个数据类型，不同的类型在内存中占用的大小是不相同的。类型分为简单类型与复合类型，先介绍简单类型

## 简单类型

| 关键字 | 存储大小byte | 说明                                                                       |
| ------ | ------------ | -------------------------------------------------------------------------- |
| int    | -            | 有符号整型，与执行平台的 cpu 位宽一致,比如 64 位下 int 占用 8byte = 64bit  |
| i8     | 1            | 有符号整型                                                                 |
| i16    | 2            | 有符号整型                                                                 |
| i32    | 4            | 有符号整型                                                                 |
| i64    | 8            | 有符号整型                                                                 |
| uint   | -            | 无符号整型，与目标平台 cpu 位宽 一致                                       |
| u8     | 1            | 无符号整型                                                                 |
| u16    | 2            | 无符号整型                                                                 |
| u32    | 4            | 无符号整型                                                                 |
| u64    | 8            | 无符号整型                                                                 |
| float  | -            | 浮点数，与执行平台的 cpu 位宽一致,比如 64 位 cpu 下占用 8byte, 与 f64 一致 |
| f32    | 4            | 单精度浮点数                                                               |
| f64    | 8            | 双精度浮点数                                                               |
| bool   | 1            | 布尔类型，值有 true 和 false                                                                           |

bool 类型的值是**小写**的 true 和 false，float 要注意其和 c 语言中的 float 区分。
**另外需要注意的是在 64 位系统下，c 语言的 float = f32, 而 nature 中 float = f64 是根据操作系统自适应大小的类型。**


## 复合类型
复杂类型可以理解为有简单类型组合并内置在 nature 中，不需要手动定义，比如 string 类型，其就是由多个 u8 类型组成。
>  🤔️ 由于还没有想好怎么支持/需不需要支持指针类型，所以复合类型目前阶段数据都存储在堆(heap) 中，复合类型在栈(stack) 中存储的是一个指针，指向对应的 heap 的起始地址。如下图示例

![string 类型内存结构](https://raw.githubusercontent.com/weiwenhao/pictures/main/blogs20230505183805.png)

下面是内置复合类型

| 类型名称 | 关键字    | 示例                                          | 说明                                                       |
| -------- | --------- | --------------------------------------------- | ---------------------------------------------------------- |
| string   | string    | `string str = "hello world"`                  |                                                            |
| list     | `[T]`     | `[int] list = [1, 2, 3, 4]`                   |                                                            |
| map      | `{T:T}`   | `{int:string} map = {1: "a", 2: "b"}`         | key 类型仅支持 integer/float/string                        |
| set      | `{T}`     | `{int} set = {1, 2, 3, 4}`                    |                                                            |
| tuple    | `(T)`     | `(int, bool) t = (1, true)`                   |                                                            |
| struct   | struct {} |                                               | 一般不会直接使用 struct 类型，后续自定义类型时再做详细介绍    |
| fn       | fn(T):T   | `fn(int,int):int f = fn(int a, int b):int {}` |                                                            | 


> 这里主要演示类型的定义方式，具体使用将会在后续章节说明。另外如果是变量声明的话推荐用 var 关键字进行类型推导，上面是示例，所以声明了类型出来。


## 特殊类型

### self

在结构体中直接声明函数时，用来引导结构体自身，示例
```nature
type square = struct {
    int length
    int width
    var area = fn(self s):int {
        return s.length * s.width
    }
}
```

这是 self 唯一的使用位置

### any

语法示例
```nature
int foo = 1
int bar = 2
any car = foo // v 这里发生累隐式类型转换，将 int 类型的 foo 转换成了 any 类型
int baz = car // x any 时复合类型，不能赋值给 int 类型的 baz 变量，这里需要借助类型断言来进行赋值
```

类型断言(Type Assertion)开发中，欢迎提供语法意见。


### null

目前语法上还没有支持，但是后续会有一个 null 类型，所以 null 作为保留关键字

### pointer

目前语法上还没有支持，但是关键字 ptr 需要保留给 builtin 使用


## 类型转换

显示类型转换(Type Casting) 语法开发中，欢迎提供语法意见。

### 隐式类型转换

由于没有想好显示类型转换的语法，所以当前版本中提供隐式类型转换。

> 当然，这不代表后续会删除隐式类型转换，而是会根据后续的反馈进行合适的调整

转换规则如下
- 除了 any 类型自己外的任意类型都可以转换为  any 类型
- 所有的类型都可以转换为 bool 类型，转换规则为 0/0.0/null 转换为 false，其他类型转换为 true。 ❗️特别注意比如 `string str` 再没有声明右值时其值为 null，所以转换为 bool 类型时是 false，`string str = ""` 此时声明了右值，即使字符串为空，转换为 bool 类型也是 true。所有的复合类型基本都遵循这样的规则，所以空 list/空 set 等都会转换为 true
- number 类型之间可以随意转换，这是非常危险的隐式转换类型转换，比如
```nature
int a = -1
uint b = a 
println(b)
```
	我以为 b 的值会变成 1， 实际上 b 的输出值是 18446744073709551615


## 字面量类型

```
var foo = 1 // 字面量 1 默认为 int 类型
u8 bar = 1 // 由于字面量 1 默认为 int 类型，这里发生了隐式类型转换

var car = 1.1 // 字面量浮点型默认为 float 类型

var baz = true  // bool 类型
var baq = false // bool 类型
```

> 2 进制字面量与 16 进制字面量暂不支持，语法开发中。